/* tslint:disable */
/* eslint-disable */
/**
 * Gnosis Safe Transaction Service API
 * API to keep track of transactions sent via Gnosis Safe smart contracts
 *
 * OpenAPI spec version: v1
 * Contact: safe@gnosis.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AllTransactionsSchema } from '../models';
import { InlineResponse2003 } from '../models';
import { InlineResponse2004 } from '../models';
import { InlineResponse2005 } from '../models';
import { SafeBalanceResponse } from '../models';
import { SafeBalanceUsdResponse } from '../models';
import { SafeCollectibleResponse } from '../models';
import { SafeCreationInfoResponse } from '../models';
import { SafeDelegate } from '../models';
import { SafeDelegateDelete } from '../models';
import { SafeInfoResponse } from '../models';
import { SafeMultisigTransaction } from '../models';
import { SafeMultisigTransactionEstimate } from '../models';
import { SafeMultisigTransactionEstimateResponse } from '../models';
import { TransferResponse } from '../models';
import { URLSearchParams, URL } from 'url';

/**
 * SafesApi - axios parameter creator
 * @export
 */
export const SafesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of transactions for a Safe. The list has different structures depending on the transaction type: - Multisig Transactions for a Safe. `tx_type=MULTISIG_TRANSACTION`. If the query parameter `queued=False` is set only the transactions with `safe nonce < current Safe nonce` will be displayed. By default, only the `trusted` transactions will be displayed (transactions indexed, with at least one confirmation or proposed by a delegate). If you need that behaviour to be disabled set the query parameter `trusted=False` - Module Transactions for a Safe. `tx_type=MODULE_TRANSACTION` - Incoming Transfers of Ether/ERC20 Tokens/ERC721 Tokens. `tx_type=ETHEREUM_TRANSACTION`
         * @param {string} address 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [executed] If &#x60;True&#x60; only executed transactions are returned
         * @param {boolean} [queued] If &#x60;True&#x60; transactions with &#x60;nonce &gt;&#x3D; Safe current nonce&#x60; are also returned
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted transactions are shown (indexed, added by a delegate or with at least one confirmation)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesAllTransactionsList: async (address: string, ordering?: string, limit?: number, offset?: number, executed?: boolean, queued?: boolean, trusted?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesAllTransactionsList.');
            }
            const localVarPath = `/safes/{address}/all-transactions/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (executed !== undefined) {
                localVarQueryParameter['executed'] = executed;
            }

            if (queued !== undefined) {
                localVarQueryParameter['queued'] = queued;
            }

            if (trusted !== undefined) {
                localVarQueryParameter['trusted'] = trusted;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get balance for Ether and ERC20 tokens
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesBalancesList: async (address: string, trusted?: boolean, excludeSpam?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesBalancesList.');
            }
            const localVarPath = `/safes/{address}/balances/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (trusted !== undefined) {
                localVarQueryParameter['trusted'] = trusted;
            }

            if (excludeSpam !== undefined) {
                localVarQueryParameter['exclude_spam'] = excludeSpam;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get balance for Ether and ERC20 tokens with USD fiat conversion
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesBalancesUsdList: async (address: string, trusted?: boolean, excludeSpam?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesBalancesUsdList.');
            }
            const localVarPath = `/safes/{address}/balances/usd/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (trusted !== undefined) {
                localVarQueryParameter['trusted'] = trusted;
            }

            if (excludeSpam !== undefined) {
                localVarQueryParameter['exclude_spam'] = excludeSpam;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get collectibles (ERC721 tokens) and information about them
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesCollectiblesList: async (address: string, trusted?: boolean, excludeSpam?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesCollectiblesList.');
            }
            const localVarPath = `/safes/{address}/collectibles/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (trusted !== undefined) {
                localVarQueryParameter['trusted'] = trusted;
            }

            if (excludeSpam !== undefined) {
                localVarQueryParameter['exclude_spam'] = excludeSpam;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the safe
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesCreationList: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesCreationList.');
            }
            const localVarPath = `/safes/{address}/creation/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or signer will update the label or delegator if different. For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals) For signature this hash need to be signed: keccak(address + str(int(current_epoch // 3600))) For example:      - we want to add the owner `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.      - TOTP = epoch // 3600 = 1586779140 // 3600 = 440771      - The hash to sign by a Safe owner would be `keccak(\"0x132512f995866CcE1b0092384A6118EDaF4508Ff440771\")`
         * @param {SafeDelegate} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesDelegatesCreate: async (body: SafeDelegate, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling safesDelegatesCreate.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesDelegatesCreate.');
            }
            const localVarPath = `/safes/{address}/delegates/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a delegate for a Safe. Signature is built the same way that for adding a delegate. Check `POST /delegates/`
         * @param {SafeDelegateDelete} body 
         * @param {string} address 
         * @param {string} delegateAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesDelegatesDelete: async (body: SafeDelegateDelete, address: string, delegateAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling safesDelegatesDelete.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesDelegatesDelete.');
            }
            // verify required parameter 'delegateAddress' is not null or undefined
            if (delegateAddress === null || delegateAddress === undefined) {
                throw new RequiredError('delegateAddress','Required parameter delegateAddress was null or undefined when calling safesDelegatesDelete.');
            }
            const localVarPath = `/safes/{address}/delegates/{delegate_address}/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"delegate_address"}}`, encodeURIComponent(String(delegateAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of delegates for a Safe address
         * @param {string} address 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesDelegatesList: async (address: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesDelegatesList.');
            }
            const localVarPath = `/safes/{address}/delegates/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [from] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [executionDateGt] 
         * @param {string} [executionDateLt] 
         * @param {string} [to] 
         * @param {string} [tokenAddress] 
         * @param {string} [transactionHash] 
         * @param {number} [value] 
         * @param {number} [valueGt] 
         * @param {number} [valueLt] 
         * @param {string} [erc20] 
         * @param {string} [erc721] 
         * @param {string} [ether] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesIncomingTransfersList: async (address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesIncomingTransfersList.');
            }
            const localVarPath = `/safes/{address}/incoming-transfers/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (from !== undefined) {
                localVarQueryParameter['_from'] = from;
            }

            if (blockNumber !== undefined) {
                localVarQueryParameter['block_number'] = blockNumber;
            }

            if (blockNumberGt !== undefined) {
                localVarQueryParameter['block_number__gt'] = blockNumberGt;
            }

            if (blockNumberLt !== undefined) {
                localVarQueryParameter['block_number__lt'] = blockNumberLt;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date__gte'] = executionDateGte;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date__lte'] = executionDateLte;
            }

            if (executionDateGt !== undefined) {
                localVarQueryParameter['execution_date__gt'] = executionDateGt;
            }

            if (executionDateLt !== undefined) {
                localVarQueryParameter['execution_date__lt'] = executionDateLt;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (valueGt !== undefined) {
                localVarQueryParameter['value__gt'] = valueGt;
            }

            if (valueLt !== undefined) {
                localVarQueryParameter['value__lt'] = valueLt;
            }

            if (erc20 !== undefined) {
                localVarQueryParameter['erc20'] = erc20;
            }

            if (erc721 !== undefined) {
                localVarQueryParameter['erc721'] = erc721;
            }

            if (ether !== undefined) {
                localVarQueryParameter['ether'] = ether;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the module transaction of a Safe
         * @param {string} address 
         * @param {string} [safe] 
         * @param {string} [module] 
         * @param {string} [to] 
         * @param {string} [operation] 
         * @param {string} [failed] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesModuleTransactionsList: async (address: string, safe?: string, module?: string, to?: string, operation?: string, failed?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesModuleTransactionsList.');
            }
            const localVarPath = `/safes/{address}/module-transactions/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (safe !== undefined) {
                localVarQueryParameter['safe'] = safe;
            }

            if (module !== undefined) {
                localVarQueryParameter['module'] = module;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (operation !== undefined) {
                localVarQueryParameter['operation'] = operation;
            }

            if (failed !== undefined) {
                localVarQueryParameter['failed'] = failed;
            }

            if (blockNumber !== undefined) {
                localVarQueryParameter['block_number'] = blockNumber;
            }

            if (blockNumberGt !== undefined) {
                localVarQueryParameter['block_number__gt'] = blockNumberGt;
            }

            if (blockNumberLt !== undefined) {
                localVarQueryParameter['block_number__lt'] = blockNumberLt;
            }

            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
         * @param {SafeMultisigTransaction} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesMultisigTransactionsCreate: async (body: SafeMultisigTransaction, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling safesMultisigTransactionsCreate.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesMultisigTransactionsCreate.');
            }
            const localVarPath = `/safes/{address}/multisig-transactions/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimates `safeTxGas` for a Safe Multisig Transaction.
         * @param {SafeMultisigTransactionEstimate} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesMultisigTransactionsEstimationsCreate: async (body: SafeMultisigTransactionEstimate, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling safesMultisigTransactionsEstimationsCreate.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesMultisigTransactionsEstimationsCreate.');
            }
            const localVarPath = `/safes/{address}/multisig-transactions/estimations/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [failed] 
         * @param {string} [modifiedLt] 
         * @param {string} [modifiedGt] 
         * @param {string} [modifiedLte] 
         * @param {string} [modifiedGte] 
         * @param {number} [nonceLt] 
         * @param {number} [nonceGt] 
         * @param {number} [nonceLte] 
         * @param {number} [nonceGte] 
         * @param {number} [nonce] 
         * @param {string} [safeTxHash] 
         * @param {string} [to] 
         * @param {number} [valueLt] 
         * @param {number} [valueGt] 
         * @param {number} [value] 
         * @param {string} [executed] 
         * @param {string} [hasConfirmations] 
         * @param {string} [trusted] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [submissionDateGte] 
         * @param {string} [submissionDateLte] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesMultisigTransactionsList: async (address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesMultisigTransactionsList.');
            }
            const localVarPath = `/safes/{address}/multisig-transactions/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (failed !== undefined) {
                localVarQueryParameter['failed'] = failed;
            }

            if (modifiedLt !== undefined) {
                localVarQueryParameter['modified__lt'] = modifiedLt;
            }

            if (modifiedGt !== undefined) {
                localVarQueryParameter['modified__gt'] = modifiedGt;
            }

            if (modifiedLte !== undefined) {
                localVarQueryParameter['modified__lte'] = modifiedLte;
            }

            if (modifiedGte !== undefined) {
                localVarQueryParameter['modified__gte'] = modifiedGte;
            }

            if (nonceLt !== undefined) {
                localVarQueryParameter['nonce__lt'] = nonceLt;
            }

            if (nonceGt !== undefined) {
                localVarQueryParameter['nonce__gt'] = nonceGt;
            }

            if (nonceLte !== undefined) {
                localVarQueryParameter['nonce__lte'] = nonceLte;
            }

            if (nonceGte !== undefined) {
                localVarQueryParameter['nonce__gte'] = nonceGte;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (safeTxHash !== undefined) {
                localVarQueryParameter['safe_tx_hash'] = safeTxHash;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (valueLt !== undefined) {
                localVarQueryParameter['value__lt'] = valueLt;
            }

            if (valueGt !== undefined) {
                localVarQueryParameter['value__gt'] = valueGt;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (executed !== undefined) {
                localVarQueryParameter['executed'] = executed;
            }

            if (hasConfirmations !== undefined) {
                localVarQueryParameter['has_confirmations'] = hasConfirmations;
            }

            if (trusted !== undefined) {
                localVarQueryParameter['trusted'] = trusted;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date__gte'] = executionDateGte;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date__lte'] = executionDateLte;
            }

            if (submissionDateGte !== undefined) {
                localVarQueryParameter['submission_date__gte'] = submissionDateGte;
            }

            if (submissionDateLte !== undefined) {
                localVarQueryParameter['submission_date__lte'] = submissionDateLte;
            }

            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of the safe
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesRead: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesRead.');
            }
            const localVarPath = `/safes/{address}/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
         * @param {SafeMultisigTransaction} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesTransactionsCreate: async (body: SafeMultisigTransaction, address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling safesTransactionsCreate.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesTransactionsCreate.');
            }
            const localVarPath = `/safes/{address}/transactions/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [failed] 
         * @param {string} [modifiedLt] 
         * @param {string} [modifiedGt] 
         * @param {string} [modifiedLte] 
         * @param {string} [modifiedGte] 
         * @param {number} [nonceLt] 
         * @param {number} [nonceGt] 
         * @param {number} [nonceLte] 
         * @param {number} [nonceGte] 
         * @param {number} [nonce] 
         * @param {string} [safeTxHash] 
         * @param {string} [to] 
         * @param {number} [valueLt] 
         * @param {number} [valueGt] 
         * @param {number} [value] 
         * @param {string} [executed] 
         * @param {string} [hasConfirmations] 
         * @param {string} [trusted] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [submissionDateGte] 
         * @param {string} [submissionDateLte] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesTransactionsList: async (address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesTransactionsList.');
            }
            const localVarPath = `/safes/{address}/transactions/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (failed !== undefined) {
                localVarQueryParameter['failed'] = failed;
            }

            if (modifiedLt !== undefined) {
                localVarQueryParameter['modified__lt'] = modifiedLt;
            }

            if (modifiedGt !== undefined) {
                localVarQueryParameter['modified__gt'] = modifiedGt;
            }

            if (modifiedLte !== undefined) {
                localVarQueryParameter['modified__lte'] = modifiedLte;
            }

            if (modifiedGte !== undefined) {
                localVarQueryParameter['modified__gte'] = modifiedGte;
            }

            if (nonceLt !== undefined) {
                localVarQueryParameter['nonce__lt'] = nonceLt;
            }

            if (nonceGt !== undefined) {
                localVarQueryParameter['nonce__gt'] = nonceGt;
            }

            if (nonceLte !== undefined) {
                localVarQueryParameter['nonce__lte'] = nonceLte;
            }

            if (nonceGte !== undefined) {
                localVarQueryParameter['nonce__gte'] = nonceGte;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (safeTxHash !== undefined) {
                localVarQueryParameter['safe_tx_hash'] = safeTxHash;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (valueLt !== undefined) {
                localVarQueryParameter['value__lt'] = valueLt;
            }

            if (valueGt !== undefined) {
                localVarQueryParameter['value__gt'] = valueGt;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (executed !== undefined) {
                localVarQueryParameter['executed'] = executed;
            }

            if (hasConfirmations !== undefined) {
                localVarQueryParameter['has_confirmations'] = hasConfirmations;
            }

            if (trusted !== undefined) {
                localVarQueryParameter['trusted'] = trusted;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date__gte'] = executionDateGte;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date__lte'] = executionDateLte;
            }

            if (submissionDateGte !== undefined) {
                localVarQueryParameter['submission_date__gte'] = submissionDateGte;
            }

            if (submissionDateLte !== undefined) {
                localVarQueryParameter['submission_date__lte'] = submissionDateLte;
            }

            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [from] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [executionDateGt] 
         * @param {string} [executionDateLt] 
         * @param {string} [to] 
         * @param {string} [tokenAddress] 
         * @param {string} [transactionHash] 
         * @param {number} [value] 
         * @param {number} [valueGt] 
         * @param {number} [valueLt] 
         * @param {string} [erc20] 
         * @param {string} [erc721] 
         * @param {string} [ether] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesTransfersList: async (address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling safesTransfersList.');
            }
            const localVarPath = `/safes/{address}/transfers/`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required

            if (from !== undefined) {
                localVarQueryParameter['_from'] = from;
            }

            if (blockNumber !== undefined) {
                localVarQueryParameter['block_number'] = blockNumber;
            }

            if (blockNumberGt !== undefined) {
                localVarQueryParameter['block_number__gt'] = blockNumberGt;
            }

            if (blockNumberLt !== undefined) {
                localVarQueryParameter['block_number__lt'] = blockNumberLt;
            }

            if (executionDateGte !== undefined) {
                localVarQueryParameter['execution_date__gte'] = executionDateGte;
            }

            if (executionDateLte !== undefined) {
                localVarQueryParameter['execution_date__lte'] = executionDateLte;
            }

            if (executionDateGt !== undefined) {
                localVarQueryParameter['execution_date__gt'] = executionDateGt;
            }

            if (executionDateLt !== undefined) {
                localVarQueryParameter['execution_date__lt'] = executionDateLt;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['token_address'] = tokenAddress;
            }

            if (transactionHash !== undefined) {
                localVarQueryParameter['transaction_hash'] = transactionHash;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (valueGt !== undefined) {
                localVarQueryParameter['value__gt'] = valueGt;
            }

            if (valueLt !== undefined) {
                localVarQueryParameter['value__lt'] = valueLt;
            }

            if (erc20 !== undefined) {
                localVarQueryParameter['erc20'] = erc20;
            }

            if (erc721 !== undefined) {
                localVarQueryParameter['erc721'] = erc721;
            }

            if (ether !== undefined) {
                localVarQueryParameter['ether'] = ether;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafesApi - functional programming interface
 * @export
 */
export const SafesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a paginated list of transactions for a Safe. The list has different structures depending on the transaction type: - Multisig Transactions for a Safe. `tx_type=MULTISIG_TRANSACTION`. If the query parameter `queued=False` is set only the transactions with `safe nonce < current Safe nonce` will be displayed. By default, only the `trusted` transactions will be displayed (transactions indexed, with at least one confirmation or proposed by a delegate). If you need that behaviour to be disabled set the query parameter `trusted=False` - Module Transactions for a Safe. `tx_type=MODULE_TRANSACTION` - Incoming Transfers of Ether/ERC20 Tokens/ERC721 Tokens. `tx_type=ETHEREUM_TRANSACTION`
         * @param {string} address 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [executed] If &#x60;True&#x60; only executed transactions are returned
         * @param {boolean} [queued] If &#x60;True&#x60; transactions with &#x60;nonce &gt;&#x3D; Safe current nonce&#x60; are also returned
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted transactions are shown (indexed, added by a delegate or with at least one confirmation)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesAllTransactionsList(address: string, ordering?: string, limit?: number, offset?: number, executed?: boolean, queued?: boolean, trusted?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTransactionsSchema>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesAllTransactionsList(address, ordering, limit, offset, executed, queued, trusted, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get balance for Ether and ERC20 tokens
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesBalancesList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeBalanceResponse>>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesBalancesList(address, trusted, excludeSpam, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get balance for Ether and ERC20 tokens with USD fiat conversion
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesBalancesUsdList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeBalanceUsdResponse>>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesBalancesUsdList(address, trusted, excludeSpam, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get collectibles (ERC721 tokens) and information about them
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesCollectiblesList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SafeCollectibleResponse>>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesCollectiblesList(address, trusted, excludeSpam, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get status of the safe
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesCreationList(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SafeCreationInfoResponse>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesCreationList(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or signer will update the label or delegator if different. For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals) For signature this hash need to be signed: keccak(address + str(int(current_epoch // 3600))) For example:      - we want to add the owner `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.      - TOTP = epoch // 3600 = 1586779140 // 3600 = 440771      - The hash to sign by a Safe owner would be `keccak(\"0x132512f995866CcE1b0092384A6118EDaF4508Ff440771\")`
         * @param {SafeDelegate} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesDelegatesCreate(body: SafeDelegate, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesDelegatesCreate(body, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a delegate for a Safe. Signature is built the same way that for adding a delegate. Check `POST /delegates/`
         * @param {SafeDelegateDelete} body 
         * @param {string} address 
         * @param {string} delegateAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesDelegatesDelete(body: SafeDelegateDelete, address: string, delegateAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesDelegatesDelete(body, address, delegateAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the list of delegates for a Safe address
         * @param {string} address 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesDelegatesList(address: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesDelegatesList(address, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [from] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [executionDateGt] 
         * @param {string} [executionDateLt] 
         * @param {string} [to] 
         * @param {string} [tokenAddress] 
         * @param {string} [transactionHash] 
         * @param {number} [value] 
         * @param {number} [valueGt] 
         * @param {number} [valueLt] 
         * @param {string} [erc20] 
         * @param {string} [erc721] 
         * @param {string} [ether] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesIncomingTransfersList(address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesIncomingTransfersList(address, from, blockNumber, blockNumberGt, blockNumberLt, executionDateGte, executionDateLte, executionDateGt, executionDateLt, to, tokenAddress, transactionHash, value, valueGt, valueLt, erc20, erc721, ether, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the module transaction of a Safe
         * @param {string} address 
         * @param {string} [safe] 
         * @param {string} [module] 
         * @param {string} [to] 
         * @param {string} [operation] 
         * @param {string} [failed] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesModuleTransactionsList(address: string, safe?: string, module?: string, to?: string, operation?: string, failed?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesModuleTransactionsList(address, safe, module, to, operation, failed, blockNumber, blockNumberGt, blockNumberLt, transactionHash, ordering, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
         * @param {SafeMultisigTransaction} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesMultisigTransactionsCreate(body: SafeMultisigTransaction, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesMultisigTransactionsCreate(body, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Estimates `safeTxGas` for a Safe Multisig Transaction.
         * @param {SafeMultisigTransactionEstimate} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesMultisigTransactionsEstimationsCreate(body: SafeMultisigTransactionEstimate, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SafeMultisigTransactionEstimateResponse>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesMultisigTransactionsEstimationsCreate(body, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [failed] 
         * @param {string} [modifiedLt] 
         * @param {string} [modifiedGt] 
         * @param {string} [modifiedLte] 
         * @param {string} [modifiedGte] 
         * @param {number} [nonceLt] 
         * @param {number} [nonceGt] 
         * @param {number} [nonceLte] 
         * @param {number} [nonceGte] 
         * @param {number} [nonce] 
         * @param {string} [safeTxHash] 
         * @param {string} [to] 
         * @param {number} [valueLt] 
         * @param {number} [valueGt] 
         * @param {number} [value] 
         * @param {string} [executed] 
         * @param {string} [hasConfirmations] 
         * @param {string} [trusted] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [submissionDateGte] 
         * @param {string} [submissionDateLte] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesMultisigTransactionsList(address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesMultisigTransactionsList(address, failed, modifiedLt, modifiedGt, modifiedLte, modifiedGte, nonceLt, nonceGt, nonceLte, nonceGte, nonce, safeTxHash, to, valueLt, valueGt, value, executed, hasConfirmations, trusted, executionDateGte, executionDateLte, submissionDateGte, submissionDateLte, transactionHash, ordering, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get status of the safe
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesRead(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SafeInfoResponse>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesRead(address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
         * @param {SafeMultisigTransaction} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesTransactionsCreate(body: SafeMultisigTransaction, address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesTransactionsCreate(body, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [failed] 
         * @param {string} [modifiedLt] 
         * @param {string} [modifiedGt] 
         * @param {string} [modifiedLte] 
         * @param {string} [modifiedGte] 
         * @param {number} [nonceLt] 
         * @param {number} [nonceGt] 
         * @param {number} [nonceLte] 
         * @param {number} [nonceGte] 
         * @param {number} [nonce] 
         * @param {string} [safeTxHash] 
         * @param {string} [to] 
         * @param {number} [valueLt] 
         * @param {number} [valueGt] 
         * @param {number} [value] 
         * @param {string} [executed] 
         * @param {string} [hasConfirmations] 
         * @param {string} [trusted] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [submissionDateGte] 
         * @param {string} [submissionDateLte] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesTransactionsList(address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesTransactionsList(address, failed, modifiedLt, modifiedGt, modifiedLte, modifiedGte, nonceLt, nonceGt, nonceLte, nonceGte, nonce, safeTxHash, to, valueLt, valueGt, value, executed, hasConfirmations, trusted, executionDateGte, executionDateLte, submissionDateGte, submissionDateLte, transactionHash, ordering, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [from] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [executionDateGt] 
         * @param {string} [executionDateLt] 
         * @param {string} [to] 
         * @param {string} [tokenAddress] 
         * @param {string} [transactionHash] 
         * @param {number} [value] 
         * @param {number} [valueGt] 
         * @param {number} [valueLt] 
         * @param {string} [erc20] 
         * @param {string} [erc721] 
         * @param {string} [ether] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async safesTransfersList(address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransferResponse>>> {
            const localVarAxiosArgs = await SafesApiAxiosParamCreator(configuration).safesTransfersList(address, from, blockNumber, blockNumberGt, blockNumberLt, executionDateGte, executionDateLte, executionDateGt, executionDateLt, to, tokenAddress, transactionHash, value, valueGt, valueLt, erc20, erc721, ether, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SafesApi - factory interface
 * @export
 */
export const SafesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a paginated list of transactions for a Safe. The list has different structures depending on the transaction type: - Multisig Transactions for a Safe. `tx_type=MULTISIG_TRANSACTION`. If the query parameter `queued=False` is set only the transactions with `safe nonce < current Safe nonce` will be displayed. By default, only the `trusted` transactions will be displayed (transactions indexed, with at least one confirmation or proposed by a delegate). If you need that behaviour to be disabled set the query parameter `trusted=False` - Module Transactions for a Safe. `tx_type=MODULE_TRANSACTION` - Incoming Transfers of Ether/ERC20 Tokens/ERC721 Tokens. `tx_type=ETHEREUM_TRANSACTION`
         * @param {string} address 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [executed] If &#x60;True&#x60; only executed transactions are returned
         * @param {boolean} [queued] If &#x60;True&#x60; transactions with &#x60;nonce &gt;&#x3D; Safe current nonce&#x60; are also returned
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted transactions are shown (indexed, added by a delegate or with at least one confirmation)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesAllTransactionsList(address: string, ordering?: string, limit?: number, offset?: number, executed?: boolean, queued?: boolean, trusted?: boolean, options?: any): AxiosPromise<AllTransactionsSchema> {
            return SafesApiFp(configuration).safesAllTransactionsList(address, ordering, limit, offset, executed, queued, trusted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get balance for Ether and ERC20 tokens
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesBalancesList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any): AxiosPromise<Array<SafeBalanceResponse>> {
            return SafesApiFp(configuration).safesBalancesList(address, trusted, excludeSpam, options).then((request) => request(axios, basePath));
        },
        /**
         * Get balance for Ether and ERC20 tokens with USD fiat conversion
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesBalancesUsdList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any): AxiosPromise<Array<SafeBalanceUsdResponse>> {
            return SafesApiFp(configuration).safesBalancesUsdList(address, trusted, excludeSpam, options).then((request) => request(axios, basePath));
        },
        /**
         * Get collectibles (ERC721 tokens) and information about them
         * @param {string} address 
         * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
         * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesCollectiblesList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any): AxiosPromise<Array<SafeCollectibleResponse>> {
            return SafesApiFp(configuration).safesCollectiblesList(address, trusted, excludeSpam, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the safe
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesCreationList(address: string, options?: any): AxiosPromise<SafeCreationInfoResponse> {
            return SafesApiFp(configuration).safesCreationList(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or signer will update the label or delegator if different. For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals) For signature this hash need to be signed: keccak(address + str(int(current_epoch // 3600))) For example:      - we want to add the owner `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.      - TOTP = epoch // 3600 = 1586779140 // 3600 = 440771      - The hash to sign by a Safe owner would be `keccak(\"0x132512f995866CcE1b0092384A6118EDaF4508Ff440771\")`
         * @param {SafeDelegate} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesDelegatesCreate(body: SafeDelegate, address: string, options?: any): AxiosPromise<void> {
            return SafesApiFp(configuration).safesDelegatesCreate(body, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a delegate for a Safe. Signature is built the same way that for adding a delegate. Check `POST /delegates/`
         * @param {SafeDelegateDelete} body 
         * @param {string} address 
         * @param {string} delegateAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesDelegatesDelete(body: SafeDelegateDelete, address: string, delegateAddress: string, options?: any): AxiosPromise<void> {
            return SafesApiFp(configuration).safesDelegatesDelete(body, address, delegateAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of delegates for a Safe address
         * @param {string} address 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesDelegatesList(address: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return SafesApiFp(configuration).safesDelegatesList(address, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [from] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [executionDateGt] 
         * @param {string} [executionDateLt] 
         * @param {string} [to] 
         * @param {string} [tokenAddress] 
         * @param {string} [transactionHash] 
         * @param {number} [value] 
         * @param {number} [valueGt] 
         * @param {number} [valueLt] 
         * @param {string} [erc20] 
         * @param {string} [erc721] 
         * @param {string} [ether] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesIncomingTransfersList(address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<TransferResponse>> {
            return SafesApiFp(configuration).safesIncomingTransfersList(address, from, blockNumber, blockNumberGt, blockNumberLt, executionDateGte, executionDateLte, executionDateGt, executionDateLt, to, tokenAddress, transactionHash, value, valueGt, valueLt, erc20, erc721, ether, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the module transaction of a Safe
         * @param {string} address 
         * @param {string} [safe] 
         * @param {string} [module] 
         * @param {string} [to] 
         * @param {string} [operation] 
         * @param {string} [failed] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesModuleTransactionsList(address: string, safe?: string, module?: string, to?: string, operation?: string, failed?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return SafesApiFp(configuration).safesModuleTransactionsList(address, safe, module, to, operation, failed, blockNumber, blockNumberGt, blockNumberLt, transactionHash, ordering, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
         * @param {SafeMultisigTransaction} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesMultisigTransactionsCreate(body: SafeMultisigTransaction, address: string, options?: any): AxiosPromise<void> {
            return SafesApiFp(configuration).safesMultisigTransactionsCreate(body, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimates `safeTxGas` for a Safe Multisig Transaction.
         * @param {SafeMultisigTransactionEstimate} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesMultisigTransactionsEstimationsCreate(body: SafeMultisigTransactionEstimate, address: string, options?: any): AxiosPromise<SafeMultisigTransactionEstimateResponse> {
            return SafesApiFp(configuration).safesMultisigTransactionsEstimationsCreate(body, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [failed] 
         * @param {string} [modifiedLt] 
         * @param {string} [modifiedGt] 
         * @param {string} [modifiedLte] 
         * @param {string} [modifiedGte] 
         * @param {number} [nonceLt] 
         * @param {number} [nonceGt] 
         * @param {number} [nonceLte] 
         * @param {number} [nonceGte] 
         * @param {number} [nonce] 
         * @param {string} [safeTxHash] 
         * @param {string} [to] 
         * @param {number} [valueLt] 
         * @param {number} [valueGt] 
         * @param {number} [value] 
         * @param {string} [executed] 
         * @param {string} [hasConfirmations] 
         * @param {string} [trusted] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [submissionDateGte] 
         * @param {string} [submissionDateLte] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesMultisigTransactionsList(address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return SafesApiFp(configuration).safesMultisigTransactionsList(address, failed, modifiedLt, modifiedGt, modifiedLte, modifiedGte, nonceLt, nonceGt, nonceLte, nonceGte, nonce, safeTxHash, to, valueLt, valueGt, value, executed, hasConfirmations, trusted, executionDateGte, executionDateLte, submissionDateGte, submissionDateLte, transactionHash, ordering, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of the safe
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesRead(address: string, options?: any): AxiosPromise<SafeInfoResponse> {
            return SafesApiFp(configuration).safesRead(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
         * @param {SafeMultisigTransaction} body 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesTransactionsCreate(body: SafeMultisigTransaction, address: string, options?: any): AxiosPromise<void> {
            return SafesApiFp(configuration).safesTransactionsCreate(body, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [failed] 
         * @param {string} [modifiedLt] 
         * @param {string} [modifiedGt] 
         * @param {string} [modifiedLte] 
         * @param {string} [modifiedGte] 
         * @param {number} [nonceLt] 
         * @param {number} [nonceGt] 
         * @param {number} [nonceLte] 
         * @param {number} [nonceGte] 
         * @param {number} [nonce] 
         * @param {string} [safeTxHash] 
         * @param {string} [to] 
         * @param {number} [valueLt] 
         * @param {number} [valueGt] 
         * @param {number} [value] 
         * @param {string} [executed] 
         * @param {string} [hasConfirmations] 
         * @param {string} [trusted] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [submissionDateGte] 
         * @param {string} [submissionDateLte] 
         * @param {string} [transactionHash] 
         * @param {string} [ordering] Which field to use when ordering the results.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesTransactionsList(address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return SafesApiFp(configuration).safesTransactionsList(address, failed, modifiedLt, modifiedGt, modifiedLte, modifiedGte, nonceLt, nonceGt, nonceLte, nonceGte, nonce, safeTxHash, to, valueLt, valueGt, value, executed, hasConfirmations, trusted, executionDateGte, executionDateLte, submissionDateGte, submissionDateLte, transactionHash, ordering, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the history of a multisig tx (safe)
         * @param {string} address 
         * @param {string} [from] 
         * @param {number} [blockNumber] 
         * @param {number} [blockNumberGt] 
         * @param {number} [blockNumberLt] 
         * @param {string} [executionDateGte] 
         * @param {string} [executionDateLte] 
         * @param {string} [executionDateGt] 
         * @param {string} [executionDateLt] 
         * @param {string} [to] 
         * @param {string} [tokenAddress] 
         * @param {string} [transactionHash] 
         * @param {number} [value] 
         * @param {number} [valueGt] 
         * @param {number} [valueLt] 
         * @param {string} [erc20] 
         * @param {string} [erc721] 
         * @param {string} [ether] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        safesTransfersList(address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<TransferResponse>> {
            return SafesApiFp(configuration).safesTransfersList(address, from, blockNumber, blockNumberGt, blockNumberLt, executionDateGte, executionDateLte, executionDateGt, executionDateLt, to, tokenAddress, transactionHash, value, valueGt, valueLt, erc20, erc721, ether, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafesApi - object-oriented interface
 * @export
 * @class SafesApi
 * @extends {BaseAPI}
 */
export class SafesApi extends BaseAPI {
    /**
     * Returns a paginated list of transactions for a Safe. The list has different structures depending on the transaction type: - Multisig Transactions for a Safe. `tx_type=MULTISIG_TRANSACTION`. If the query parameter `queued=False` is set only the transactions with `safe nonce < current Safe nonce` will be displayed. By default, only the `trusted` transactions will be displayed (transactions indexed, with at least one confirmation or proposed by a delegate). If you need that behaviour to be disabled set the query parameter `trusted=False` - Module Transactions for a Safe. `tx_type=MODULE_TRANSACTION` - Incoming Transfers of Ether/ERC20 Tokens/ERC721 Tokens. `tx_type=ETHEREUM_TRANSACTION`
     * @param {string} address 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {boolean} [executed] If &#x60;True&#x60; only executed transactions are returned
     * @param {boolean} [queued] If &#x60;True&#x60; transactions with &#x60;nonce &gt;&#x3D; Safe current nonce&#x60; are also returned
     * @param {boolean} [trusted] If &#x60;True&#x60; just trusted transactions are shown (indexed, added by a delegate or with at least one confirmation)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesAllTransactionsList(address: string, ordering?: string, limit?: number, offset?: number, executed?: boolean, queued?: boolean, trusted?: boolean, options?: any) {
        return SafesApiFp(this.configuration).safesAllTransactionsList(address, ordering, limit, offset, executed, queued, trusted, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get balance for Ether and ERC20 tokens
     * @param {string} address 
     * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
     * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesBalancesList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any) {
        return SafesApiFp(this.configuration).safesBalancesList(address, trusted, excludeSpam, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get balance for Ether and ERC20 tokens with USD fiat conversion
     * @param {string} address 
     * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
     * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesBalancesUsdList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any) {
        return SafesApiFp(this.configuration).safesBalancesUsdList(address, trusted, excludeSpam, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get collectibles (ERC721 tokens) and information about them
     * @param {string} address 
     * @param {boolean} [trusted] If &#x60;True&#x60; just trusted tokens will be returned
     * @param {boolean} [excludeSpam] If &#x60;True&#x60; spam tokens will not be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesCollectiblesList(address: string, trusted?: boolean, excludeSpam?: boolean, options?: any) {
        return SafesApiFp(this.configuration).safesCollectiblesList(address, trusted, excludeSpam, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get status of the safe
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesCreationList(address: string, options?: any) {
        return SafesApiFp(this.configuration).safesCreationList(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a delegate for a Safe address with a custom label. Calls with same delegate but different label or signer will update the label or delegator if different. For the signature we are using TOTP with `T0=0` and `Tx=3600`. TOTP is calculated by taking the Unix UTC epoch time (no milliseconds) and dividing by 3600 (natural division, no decimals) For signature this hash need to be signed: keccak(address + str(int(current_epoch // 3600))) For example:      - we want to add the owner `0x132512f995866CcE1b0092384A6118EDaF4508Ff` and `epoch=1586779140`.      - TOTP = epoch // 3600 = 1586779140 // 3600 = 440771      - The hash to sign by a Safe owner would be `keccak(\"0x132512f995866CcE1b0092384A6118EDaF4508Ff440771\")`
     * @param {SafeDelegate} body 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesDelegatesCreate(body: SafeDelegate, address: string, options?: any) {
        return SafesApiFp(this.configuration).safesDelegatesCreate(body, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a delegate for a Safe. Signature is built the same way that for adding a delegate. Check `POST /delegates/`
     * @param {SafeDelegateDelete} body 
     * @param {string} address 
     * @param {string} delegateAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesDelegatesDelete(body: SafeDelegateDelete, address: string, delegateAddress: string, options?: any) {
        return SafesApiFp(this.configuration).safesDelegatesDelete(body, address, delegateAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the list of delegates for a Safe address
     * @param {string} address 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesDelegatesList(address: string, limit?: number, offset?: number, options?: any) {
        return SafesApiFp(this.configuration).safesDelegatesList(address, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the history of a multisig tx (safe)
     * @param {string} address 
     * @param {string} [from] 
     * @param {number} [blockNumber] 
     * @param {number} [blockNumberGt] 
     * @param {number} [blockNumberLt] 
     * @param {string} [executionDateGte] 
     * @param {string} [executionDateLte] 
     * @param {string} [executionDateGt] 
     * @param {string} [executionDateLt] 
     * @param {string} [to] 
     * @param {string} [tokenAddress] 
     * @param {string} [transactionHash] 
     * @param {number} [value] 
     * @param {number} [valueGt] 
     * @param {number} [valueLt] 
     * @param {string} [erc20] 
     * @param {string} [erc721] 
     * @param {string} [ether] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesIncomingTransfersList(address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options?: any) {
        return SafesApiFp(this.configuration).safesIncomingTransfersList(address, from, blockNumber, blockNumberGt, blockNumberLt, executionDateGte, executionDateLte, executionDateGt, executionDateLt, to, tokenAddress, transactionHash, value, valueGt, valueLt, erc20, erc721, ether, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the module transaction of a Safe
     * @param {string} address 
     * @param {string} [safe] 
     * @param {string} [module] 
     * @param {string} [to] 
     * @param {string} [operation] 
     * @param {string} [failed] 
     * @param {number} [blockNumber] 
     * @param {number} [blockNumberGt] 
     * @param {number} [blockNumberLt] 
     * @param {string} [transactionHash] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesModuleTransactionsList(address: string, safe?: string, module?: string, to?: string, operation?: string, failed?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any) {
        return SafesApiFp(this.configuration).safesModuleTransactionsList(address, safe, module, to, operation, failed, blockNumber, blockNumberGt, blockNumberLt, transactionHash, ordering, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
     * @param {SafeMultisigTransaction} body 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesMultisigTransactionsCreate(body: SafeMultisigTransaction, address: string, options?: any) {
        return SafesApiFp(this.configuration).safesMultisigTransactionsCreate(body, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Estimates `safeTxGas` for a Safe Multisig Transaction.
     * @param {SafeMultisigTransactionEstimate} body 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesMultisigTransactionsEstimationsCreate(body: SafeMultisigTransactionEstimate, address: string, options?: any) {
        return SafesApiFp(this.configuration).safesMultisigTransactionsEstimationsCreate(body, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the history of a multisig tx (safe)
     * @param {string} address 
     * @param {string} [failed] 
     * @param {string} [modifiedLt] 
     * @param {string} [modifiedGt] 
     * @param {string} [modifiedLte] 
     * @param {string} [modifiedGte] 
     * @param {number} [nonceLt] 
     * @param {number} [nonceGt] 
     * @param {number} [nonceLte] 
     * @param {number} [nonceGte] 
     * @param {number} [nonce] 
     * @param {string} [safeTxHash] 
     * @param {string} [to] 
     * @param {number} [valueLt] 
     * @param {number} [valueGt] 
     * @param {number} [value] 
     * @param {string} [executed] 
     * @param {string} [hasConfirmations] 
     * @param {string} [trusted] 
     * @param {string} [executionDateGte] 
     * @param {string} [executionDateLte] 
     * @param {string} [submissionDateGte] 
     * @param {string} [submissionDateLte] 
     * @param {string} [transactionHash] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesMultisigTransactionsList(address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any) {
        return SafesApiFp(this.configuration).safesMultisigTransactionsList(address, failed, modifiedLt, modifiedGt, modifiedLte, modifiedGte, nonceLt, nonceGt, nonceLte, nonceGte, nonce, safeTxHash, to, valueLt, valueGt, value, executed, hasConfirmations, trusted, executionDateGte, executionDateLte, submissionDateGte, submissionDateLte, transactionHash, ordering, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get status of the safe
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesRead(address: string, options?: any) {
        return SafesApiFp(this.configuration).safesRead(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a Multisig Transaction with its confirmations and retrieves all the information related.
     * @param {SafeMultisigTransaction} body 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesTransactionsCreate(body: SafeMultisigTransaction, address: string, options?: any) {
        return SafesApiFp(this.configuration).safesTransactionsCreate(body, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the history of a multisig tx (safe)
     * @param {string} address 
     * @param {string} [failed] 
     * @param {string} [modifiedLt] 
     * @param {string} [modifiedGt] 
     * @param {string} [modifiedLte] 
     * @param {string} [modifiedGte] 
     * @param {number} [nonceLt] 
     * @param {number} [nonceGt] 
     * @param {number} [nonceLte] 
     * @param {number} [nonceGte] 
     * @param {number} [nonce] 
     * @param {string} [safeTxHash] 
     * @param {string} [to] 
     * @param {number} [valueLt] 
     * @param {number} [valueGt] 
     * @param {number} [value] 
     * @param {string} [executed] 
     * @param {string} [hasConfirmations] 
     * @param {string} [trusted] 
     * @param {string} [executionDateGte] 
     * @param {string} [executionDateLte] 
     * @param {string} [submissionDateGte] 
     * @param {string} [submissionDateLte] 
     * @param {string} [transactionHash] 
     * @param {string} [ordering] Which field to use when ordering the results.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesTransactionsList(address: string, failed?: string, modifiedLt?: string, modifiedGt?: string, modifiedLte?: string, modifiedGte?: string, nonceLt?: number, nonceGt?: number, nonceLte?: number, nonceGte?: number, nonce?: number, safeTxHash?: string, to?: string, valueLt?: number, valueGt?: number, value?: number, executed?: string, hasConfirmations?: string, trusted?: string, executionDateGte?: string, executionDateLte?: string, submissionDateGte?: string, submissionDateLte?: string, transactionHash?: string, ordering?: string, limit?: number, offset?: number, options?: any) {
        return SafesApiFp(this.configuration).safesTransactionsList(address, failed, modifiedLt, modifiedGt, modifiedLte, modifiedGte, nonceLt, nonceGt, nonceLte, nonceGte, nonce, safeTxHash, to, valueLt, valueGt, value, executed, hasConfirmations, trusted, executionDateGte, executionDateLte, submissionDateGte, submissionDateLte, transactionHash, ordering, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the history of a multisig tx (safe)
     * @param {string} address 
     * @param {string} [from] 
     * @param {number} [blockNumber] 
     * @param {number} [blockNumberGt] 
     * @param {number} [blockNumberLt] 
     * @param {string} [executionDateGte] 
     * @param {string} [executionDateLte] 
     * @param {string} [executionDateGt] 
     * @param {string} [executionDateLt] 
     * @param {string} [to] 
     * @param {string} [tokenAddress] 
     * @param {string} [transactionHash] 
     * @param {number} [value] 
     * @param {number} [valueGt] 
     * @param {number} [valueLt] 
     * @param {string} [erc20] 
     * @param {string} [erc721] 
     * @param {string} [ether] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafesApi
     */
    public safesTransfersList(address: string, from?: string, blockNumber?: number, blockNumberGt?: number, blockNumberLt?: number, executionDateGte?: string, executionDateLte?: string, executionDateGt?: string, executionDateLt?: string, to?: string, tokenAddress?: string, transactionHash?: string, value?: number, valueGt?: number, valueLt?: number, erc20?: string, erc721?: string, ether?: string, limit?: number, offset?: number, options?: any) {
        return SafesApiFp(this.configuration).safesTransfersList(address, from, blockNumber, blockNumberGt, blockNumberLt, executionDateGte, executionDateLte, executionDateGt, executionDateLt, to, tokenAddress, transactionHash, value, valueGt, valueLt, erc20, erc721, ether, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}
